<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tokens da Carteira - CryptoPulse</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Inter', sans-serif; background: #0e0e10; color: #f0f0f0; line-height: 1.6; padding: 16px; }
    header { background: linear-gradient(90deg, #8b5cf6, #3b82f6, #06b6d4); padding: 16px; text-align: center; border-radius: 8px; }
    header h1 { font-size: 2rem; font-weight: 600; color: #fff; }
    .menu-icon { position: absolute; top: 50%; right: 16px; transform: translateY(-50%); font-size: 1.5rem; cursor: pointer; color: #fff; }
    .menu-icon:hover { color: #d1d5db; }
    .dropdown { display: none; position: absolute; top: 60px; right: 16px; background: #1f1f23; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); min-width: 180px; z-index: 10; }
    .dropdown a { display: block; padding: 10px 12px; color: #f0f0f0; text-decoration: none; font-size: 0.9rem; }
    .dropdown a:hover { background: #27272a; color: #93c5fd; }
    .token-section { max-width: 1100px; margin: 16px auto; }
    h2 { font-size: 1.6rem; color: #93c5fd; margin-bottom: 16px; }
    .error-message, .loading-message { text-align: center; padding: 10px; margin-bottom: 8px; border-radius: 8px; font-size: 0.9rem; }
    .error-message { background: #ef4444; color: #fff; }
    .loading-message { background: #3b82f6; color: #fff; }
    .table-container { max-width: 100%; overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; background: #1f1f23; border-radius: 8px; }
    th, td { padding: 10px 12px; text-align: left; font-size: 0.9rem; }
    th { color: #93c5fd; font-weight: 600; background: #27272a; }
    tbody { max-height: 350px; overflow-y: auto; display: block; }
    tbody tr { border-bottom: 1px solid #2d2d31; display: table; width: 100%; }
    tbody tr:hover { background: #27272a; cursor: pointer; }
    .no-results { text-align: center; padding: 16px; color: #9ca3af; display: table; width: 100%; font-size: 0.8rem; }
    th:nth-child(1), td:nth-child(1) { width: 30%; }
    th:nth-child(2), td:nth-child(2) { width: 30%; }
    th:nth-child(3), td:nth-child(3) { width: 40%; }
    footer { text-align: center; padding: 12px; font-size: 0.8rem; color: #9ca3af; border-top: 1px solid #2d2d31; }
    @media (max-width: 600px) {
      body { padding: 12px; }
      header { padding: 12px; }
      header h1 { font-size: 1.8rem; }
      th, td { font-size: 0.8rem; padding: 8px 10px; }
      .no-results { font-size: 0.7rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>CryptoPulse - Tokens</h1>
    <span class="menu-icon" onclick="toggleDropdown()">☰</span>
    <div class="dropdown" id="crypto-links">
      <a href="index.html">Mercado</a>
      <a href="portfolio.html">Portfolio</a>
      <a href="tools.html">Rastreador</a>
      <a href="https://coinmarketcap.com" target="_blank">CoinMarketCap</a>
      <a href="https://www.coingecko.com" target="_blank">CoinGecko</a>
      <a href="https://www.tradingview.com" target="_blank">TradingView</a>
      <a href="https://messari.io" target="_blank">Messari</a>
      <a href="https://defillama.com" target="_blank">DefiLlama</a>
      <a href="https://cryptoquant.com" target="_blank">CryptoQuant</a>
      <a href="https://token.unlocks.app" target="_blank">Token Unlocks</a>
      <a href="https://dune.com" target="_blank">Dune Analytics</a>
      <a href="https://lunarcrush.com" target="_blank">LunarCrush</a>
      <a href="https://whale-alert.io" target="_blank">Whale Alert</a>
      <a href="https://www.binance.com" target="_blank">Binance</a>
      <a href="https://www.coinbase.com" target="_blank">Coinbase</a>
      <a href="https://www.coindesk.com" target="_blank">CoinDesk</a>
    </div>
  </header>
  <div class="token-section">
    <h2>Tokens da Carteira</h2>
    <div id="status-message"></div>
    <div class="table-container">
      <table id="token-table">
        <thead>
          <tr>
            <th>Símbolo</th>
            <th>Saldo</th>
            <th>Valor (BRL)</th>
          </tr>
        </thead>
        <tbody id="token-table-body"></tbody>
      </table>
    </div>
  </div>
  <footer>© 2025 CryptoPulse | Dados: CoinMarketCap, Etherscan, BscScan, Solscan</footer>
  <script>
    const cmcApiKey = "9e0ef985-caf5-43d3-90e0-a73304b5546e";
    const etherscanApiKey = "D6DM8WTG21IFNBTT337SWZE7B4MWIAIC4Z";
    const bscscanApiKey = "B5I5TUJB6JV8A8U7X2HPYZEYVKGEKCUXRJ";
    const cacheTTL = 300000;

    function toggleDropdown() {
      const dropdown = document.getElementById('crypto-links');
      dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
    }

    document.addEventListener('click', e => {
      const dropdown = document.getElementById('crypto-links');
      if (!dropdown.contains(e.target) && !e.target.closest('.menu-icon')) dropdown.style.display = 'none';
    });

    function showStatusMessage(message, type = 'error') {
      document.getElementById('status-message').innerHTML = `<div class="${type}-message">${message}</div>`;
      setTimeout(() => document.getElementById('status-message').innerHTML = '', 3000);
    }

    function getCachedData(key, fetchFn) {
      const cached = localStorage.getItem(key);
      if (cached) {
        const { data, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp < cacheTTL) return Promise.resolve(data);
      }
      return fetchFn().then(data => {
        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
        return data;
      }).catch(err => { throw err; });
    }

    async function getPrice(symbol) {
      return getCachedData(`price_${symbol}`, async () => {
        const res = await fetch(`https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=${symbol}&convert=BRL`, {
          headers: { "X-CMC_PRO_API_KEY": cmcApiKey }
        });
        const data = await res.json();
        if (data.status.error_code !== 0) throw new Error('Erro na API CoinMarketCap');
        return data.data[symbol].quote.BRL.price;
      }).catch(() => null);
    }

    async function fetchTokens(address, blockchain) {
      const tokens = [];
      let nativeBalance = 0, nativeSymbol, nativePrice;

      try {
        if (blockchain === 'ethereum') {
          nativeSymbol = 'ETH';
          const balanceData = await getCachedData(`eth_balance_${address}`, async () => {
            const res = await fetch(`https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=${etherscanApiKey}`);
            const data = await res.json();
            if (data.status !== "1") throw new Error('Erro na API Etherscan');
            return data;
          });
          nativeBalance = balanceData.result / 1e18;
          nativePrice = await getPrice('ETH');
          if (nativePrice && nativeBalance > 0) tokens.push({ symbol: nativeSymbol, balance: nativeBalance.toFixed(4), valueBRL: (nativeBalance * nativePrice).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }) });
          const tokenTxData = await getCachedData(`eth_tokentx_${address}`, async () => {
            const res = await fetch(`https://api.etherscan.io/api?module=account&action=tokentx&address=${address}&sort=desc&apikey=${etherscanApiKey}`);
            const data = await res.json();
            if (data.status !== "1") return { result: [] };
            return data;
          });
          if (tokenTxData.result.length > 0) {
            const uniqueTokens = [...new Set(tokenTxData.result.map(tx => tx.contractAddress))].slice(0, 5);
            for (const contract of uniqueTokens) {
              const token = tokenTxData.result.find(tx => tx.contractAddress === contract);
              const balanceData = await getCachedData(`eth_tokenbalance_${contract}_${address}`, async () => {
                const res = await fetch(`https://api.etherscan.io/api?module=account&action=tokenbalance&contractaddress=${contract}&address=${address}&tag=latest&apikey=${etherscanApiKey}`);
                const data = await res.json();
                if (data.status !== "1") return { result: 0 };
                return data;
              });
              if (balanceData.result > 0) {
                const balance = balanceData.result / Math.pow(10, parseInt(token.tokenDecimal || 18));
                const price = await getPrice(token.tokenSymbol);
                if (price && balance > 0) {
                  tokens.push({
                    symbol: token.tokenSymbol || 'N/A',
                    balance: balance.toFixed(4),
                    valueBRL: (balance * price).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })
                  });
                }
              }
            }
          }
        } else if (blockchain === 'bsc') {
          nativeSymbol = 'BNB';
          const balanceData = await getCachedData(`bsc_balance_${address}`, async () => {
            const res = await fetch(`https://api.bscscan.com/api?module=account&action=balance&address=${address}&tag=latest&apikey=${bscscanApiKey}`);
            const data = await res.json();
            if (data.status !== "1") throw new Error('Erro na API BscScan');
            return data;
          });
          nativeBalance = balanceData.result / 1e18;
          nativePrice = await getPrice('BNB');
          if (nativePrice && nativeBalance > 0) tokens.push({ symbol: nativeSymbol, balance: nativeBalance.toFixed(4), valueBRL: (nativeBalance * nativePrice).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }) });
          const tokenTxData = await getCachedData(`bsc_tokentx_${address}`, async () => {
            const res = await fetch(`https://api.bscscan.com/api?module=account&action=tokentx&address=${address}&sort=desc&apikey=${bscscanApiKey}`);
            const data = await res.json();
            if (data.status !== "1") return { result: [] };
            return data;
          });
          if (tokenTxData.result.length > 0) {
            const uniqueTokens = [...new Set(tokenTxData.result.map(tx => tx.contractAddress))].slice(0, 5);
            for (const contract of uniqueTokens) {
              const token = tokenTxData.result.find(tx => tx.contractAddress === contract);
              const balanceData = await getCachedData(`bsc_tokenbalance_${contract}_${address}`, async () => {
                const res = await fetch(`https://api.bscscan.com/api?module=account&action=tokenbalance&contractaddress=${contract}&address=${address}&tag=latest&apikey=${bscscanApiKey}`);
                const data = await res.json();
                if (data.status !== "1") return { result: 0 };
                return data;
              });
              if (balanceData.result > 0) {
                const balance = balanceData.result / Math.pow(10, parseInt(token.tokenDecimal || 18));
                const price = await getPrice(token.tokenSymbol);
                if (price && balance > 0) {
                  tokens.push({
                    symbol: token.tokenSymbol || 'N/A',
                    balance: balance.toFixed(4),
                    valueBRL: (balance * price).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })
                  });
                }
              }
            }
          }
        } else if (blockchain === 'solana') {
          nativeSymbol = 'SOL';
          const { Connection, PublicKey } = solanaWeb3;
          const connection = new Connection('https://api.mainnet-beta.solana.com');
          const publicKey = new PublicKey(address);
          nativeBalance = await connection.getBalance(publicKey).then(lamports => lamports / 1e9);
          nativePrice = await getPrice('SOL');
          if (nativePrice && nativeBalance > 0) tokens.push({ symbol: nativeSymbol, balance: nativeBalance.toFixed(4), valueBRL: (nativeBalance * nativePrice).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }) });
        }
        return tokens;
      } catch (err) {
        throw new Error(err.message || 'Erro ao buscar tokens');
      }
    }

    async function renderTokens() {
      const params = new URLSearchParams(window.location.search);
      const address = params.get('address');
      const blockchain = params.get('blockchain');
      const tbody = document.getElementById('token-table-body');

      if (!address || !blockchain) {
        showStatusMessage('Endereço ou blockchain não especificados.', 'error');
        tbody.innerHTML = '<tr><td colspan="3" class="no-results">Nenhum dado disponível.</td></tr>';
        return;
      }

      showStatusMessage('Carregando tokens...', 'loading');
      try {
        const tokens = await fetchTokens(address, blockchain);
        tbody.innerHTML = tokens.length ? tokens.map(token => `
          <tr>
            <td>${token.symbol}</td>
            <td>${token.balance}</td>
            <td>${token.valueBRL}</td>
          </tr>
        `).join('') : '<tr><td colspan="3" class="no-results">Nenhum token com valor encontrado.</td></tr>';
        showStatusMessage('Tokens carregados!', 'loading');
      } catch (err) {
        showStatusMessage(`Erro: ${err.message}`, 'error');
        tbody.innerHTML = '<tr><td colspan="3" class="no-results">Erro ao carregar tokens.</td></tr>';
      }
    }

    renderTokens();
  </script>
</body>
</html>